"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9252],{8101:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>t,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var i=n(7624),r=n(2172);const a={sidebar_position:8,description:"Utiliser le tableau de symboles",slug:"/tp/07"},t="07 - Analyse s\xe9mantique",l={id:"tp/07/index",title:"07 - Analyse s\xe9mantique",description:"Utiliser le tableau de symboles",source:"@site/docs/tp/07/index.md",sourceDirName:"tp/07",slug:"/tp/07",permalink:"/docs/tp/07",draft:!1,unlisted:!1,editUrl:"https://github.com/UPB-FILS-alf/upb-fils-alf.github.io/edit/main/docs/tp/07/index.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8,description:"Utiliser le tableau de symboles",slug:"/tp/07"},sidebar:"tutorialSidebar",previous:{title:"06 - Visitor et Biblioth\xe8que",permalink:"/docs/tp/06"},next:{title:"08 - G\xe9n\xe9ration de code",permalink:"/docs/tp/08"}},o={},d=[{value:"AST",id:"ast",level:2},{value:"Le tableau de symboles",id:"le-tableau-de-symboles",level:2},{value:"Port\xe9e (Scope)",id:"port\xe9e-scope",level:3},{value:"Implantation dans la biblioth\xe8que",id:"implantation-dans-la-biblioth\xe8que",level:3},{value:"Erreurs s\xe9mantiques",id:"erreurs-s\xe9mantiques",level:3},{value:"Exercices",id:"exercices",level:2},{value:"Bibliographie",id:"bibliographie",level:2}];function c(e){const s={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"07---analyse-s\xe9mantique",children:"07 - Analyse s\xe9mantique"}),"\n",(0,i.jsx)(s.h2,{id:"ast",children:"AST"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"L\u2019arbre abstrait de syntaxe"})," (",(0,i.jsx)(s.strong,{children:"abstract syntax tree"})," - AST en anglais) est une repr\xe9sentation hi\xe9rarchique du code source \xe9crit dans un langage quelconque sous la forme d\u2019un arbre. Du coup, ce qu\u2019on a commenc\xe9 le TP pr\xe9c\xe9dent (la traduction du code source dans notre collection de classes) est la cr\xe9ation de l\u2019AST."]}),"\n",(0,i.jsx)(s.p,{children:"L\u2019AST resemble l\u2019arbre d\u2019analyse (parse tree) dans la structure. La diff\xe9rence est au niveau du contenu: dans l\u2019arbre d\u2019analyse, les noeuds int\xe9ri\xe8ures \xe9taient les non-terminaux, mais dans l\u2019AST, les noeuds sont des concepts de programmation (dans notre cas, les classes)."}),"\n",(0,i.jsxs)(s.p,{children:["L'AST est ce qu'on appelle une ",(0,i.jsx)(s.strong,{children:"repr\xe9sentation interm\xe9diaire"})," (",(0,i.jsx)(s.strong,{children:"intermediate representation"}),"). On utilise les repr\xe9sentations intermediaires dans notre compilateur pour avoir une transcription de ce que le code source fait sans les contraintes du langage source."]}),"\n",(0,i.jsx)(s.h2,{id:"le-tableau-de-symboles",children:"Le tableau de symboles"}),"\n",(0,i.jsxs)(s.p,{children:["Le ",(0,i.jsx)(s.strong,{children:"tableau de symboles"})," est une structure de donn\xe9es utilis\xe9e par les compilateurs pour sauvegarder de l\u2019information sur le programme source. Les entr\xe9es du tableau de symboles contiennent l\u2019information sur les identificateurs, leurs types, leurs positions dans la m\xe9moire et tout autre choses n\xe9c\xe9ssaires. Le role d\u2019un tel tableau est de passer l\u2019information depuis les d\xe9clarations vers les utilisations."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"Symbol table",src:n(7788).c+"",width:"562",height:"189"})}),"\n",(0,i.jsx)(s.p,{children:"Le compilateur peut interagir avec le tableau de symboles dans plusieurs \xe9tapes de la compilation: dans l\u2019analyse l\xe9xicale, l\u2019analyse syntaxique ou celle s\xe9mantique. Pendants notre TPs, on va \xe9tudier seulement l\u2019utilisation pendant l\u2019analyse s\xe9mantique. C\u2019est-\xe0-dire, apr\xe8s avoir obtenu notre AST contenant une repr\xe9sentation du code source, on le parcourt pour remplir le tableau et pour faire l\u2019analyser."}),"\n",(0,i.jsx)(s.p,{children:"Les \xe9tapes sont les suivantes:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"on commence \xe0 traverser notre arbre d\u2019analyse \xe0 partir de la racine"}),"\n",(0,i.jsx)(s.li,{children:"chaque fois qu\u2019on rencontre une d\xe9finition d\u2019une variable, fonction ou type, on ajoute les nouvelles informations dans notre tableau de symboles"}),"\n",(0,i.jsx)(s.li,{children:"chaque fois qu\u2019on rencontre l\u2019utilisation d\u2019une variable, type ou fonction, on v\xe9rifie le tableau de symboles. Si on trouve une entr\xe9e qui corr\xe9spond, on peut continuer avec l\u2019analyze s\xe9mantique en utilisant l\u2019information sauvegard\xe9e dans le tableau. Autrement, en fonction des r\xe8gles de notre langage de programmation,soit on renvoie une erreur, \xe0 cause de l\u2019utilisation d\u2019un symbole pas d\xe9fini, soit on ajoute une nouvelle entr\xe9e dans le tableau."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"port\xe9e-scope",children:"Port\xe9e (Scope)"}),"\n",(0,i.jsxs)(s.p,{children:["On appelle ",(0,i.jsx)(s.strong,{children:"port\xe9e"})," (ou ",(0,i.jsx)(s.strong,{children:"scope"})," en anglais) une partie du programme o\xf9 il y a une collection d\u2019identificateurs. La port\xe9e d\u2019un identificateur quelconque repr\xe9sente la partie du programme o\xf9 cet identificateur est d\xe9fini."]}),"\n",(0,i.jsx)(s.p,{children:"Les port\xe9es sont importantes dans un langage de programmation, car le m\xeame identificateur peut \xeatre utilis\xe9 plusieurs fois dans le m\xeame programme avec des significations diff\xe9rentes. Par exemple, les noms des variables i et x sont assez communs."}),"\n",(0,i.jsxs)(s.p,{children:["Chaque langage de programmation a sa propre mani\xe8re d\u2019identifier ses port\xe9es. Dans des langages comme ",(0,i.jsx)(s.code,{children:"C"}),", ",(0,i.jsx)(s.code,{children:"Java"})," ou ",(0,i.jsx)(s.code,{children:"Kotlin"}),", on utilise les ",(0,i.jsx)(s.code,{children:"{"})," ",(0,i.jsx)(s.code,{children:"}"}),". ",(0,i.jsx)(s.code,{children:"Python"}),", au contraire, emploie l\u2019identation des lignes pour \xe9tablir ses port\xe9es."]}),"\n",(0,i.jsx)(s.h3,{id:"implantation-dans-la-biblioth\xe8que",children:"Implantation dans la biblioth\xe8que"}),"\n",(0,i.jsxs)(s.p,{children:["Ouvrez la documentation et cherchez la classe ",(0,i.jsx)(s.code,{children:"domain.SymbolTable"}),". Observez qu\u2019on gardera trois choses dans nos tableaux de symboles: les variables, les fonctions et les types. Pour le types, on gardera des instances pour les primitives du langage (donc pour des types comme ",(0,i.jsx)(s.code,{children:"Boolean"})," ou ",(0,i.jsx)(s.code,{children:"String"}),"), mais aussi pour les types d\xe9finis par l\u2019utilisateur."]}),"\n",(0,i.jsxs)(s.p,{children:['Dans notre biblioth\xe8que, l\u2019int\xe9gration du tableau de symboles se passe au niveau du chaque port\xe9e. C\u2019est-\xe0-dire, chaque fois qu\u2019une nouvelle port\xe9e commence, on cr\xe9e une nouvelle instance de la classe SymbolTable, qui gardera les informations "locales", donc les d\xe9finitions qui existent seulement dedans. G\xe9n\xe9ralement, une nouvelle port\xe9e est cr\xe9e au moment qu\u2019on rencontre une nouvelle instance de la classe ',(0,i.jsx)(s.code,{children:"Block"}),". Du point de vue logice, cette instance corr\xe9spond exactement \xe0 une port\xe9e. Le tableau de symboles associ\xe9 \xe0 une instance se trouve dans le champs ",(0,i.jsx)(s.code,{children:"scope"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"Avec notre approche, quand on v\xe9rifie l\u2019existence d\u2019un identificateur dans le code source, chercher dans la port\xe9e courante ne suffit pas. On peut avoir des situations ou une variable a \xe9t\xe9 d\xe9clar\xe9e dans une port\xe9e sup\xe9rieure et on veut l\u2019utiliser dans une port\xe9e int\xe9rieure. Par exemple, si on d\xe9clare une variable avant une instruction if et on veut l\u2019utiliser dans l\u2019une de ses branches, il faut pouvoir l\u2019acc\xe9der \xe0 l\u2019interieur de la port\xe9e corr\xe9spondante."}),"\n",(0,i.jsxs)(s.p,{children:["Ce qu\u2019on doit faire, c\u2019est aller plus haut dans l\u2019hi\xe9rarchie et chercher l\u2019identificateur dans les tableaux de symboles sup\xe9rieures. Pour cela, on utilise le champ ",(0,i.jsx)(s.code,{children:"owner"})," de la classe ",(0,i.jsx)(s.code,{children:"SymbolTable"}),", qui renvoie le parent ."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-kotlin",children:"var scope = node.scope\nwhile(scope!=null){\n    \n    //recherche de l\u2019information dont on a besoin\n\n    scope = scope.owner.parent?.scope\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:"Une visualisation graphique de ce processus:"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"Chained symbol tables",src:n(6596).c+"",width:"473",height:"205"})}),"\n",(0,i.jsxs)(s.admonition,{type:"tip",children:[(0,i.jsx)(s.p,{children:"Apr\xe8s avoir pass\xe9 l\u2019\xe9tape d\u2019analyse s\xe9mantique de notre compilateur, l\u2019AST ne contiendra plus de d\xe9clarations et d\xe9finitions. On retrouvera toutes leurs informations dans les tableaux de symboles, alors on n\u2019aura plus besoin de les garder. Plus pr\xe9cisement, les cons\xe9quences sont:"}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["les instance de la classe ",(0,i.jsx)(s.code,{children:"Definition"})," disparaissent"]}),"\n",(0,i.jsxs)(s.li,{children:["les d\xe9finitions des variables disparaissent aussi. Si une d\xe9finition contient aussi une valeur d\u2019initialisation (c\u2019est-\xe0-dire, le champ ",(0,i.jsx)(s.code,{children:"init"}),"), on la remplacera avec une affectation (une instance de la classe ",(0,i.jsx)(s.code,{children:"Assignment"}),")."]}),"\n"]})]}),"\n",(0,i.jsx)(s.h3,{id:"erreurs-s\xe9mantiques",children:"Erreurs s\xe9mantiques"}),"\n",(0,i.jsxs)(s.p,{children:["Au contraire aux erreurs lexicales et syntaxiques, on peut anticiper les erreurs s\xe9mantiques possibles dans notre langage de programmation. Pour les repr\xe9senter, on utilise la classe ",(0,i.jsx)(s.code,{children:"domain.SemanticError"})," de notre biblioth\xe8que."]}),"\n",(0,i.jsxs)(s.p,{children:["On vous conseil de consulter cette classe et les valeurs du ",(0,i.jsx)(s.code,{children:"SemanticError.Type"})," avant commencer les exercices."]}),"\n",(0,i.jsx)(s.h2,{id:"exercices",children:"Exercices"}),"\n",(0,i.jsxs)(s.p,{children:["Ouvrez le fichier ",(0,i.jsx)(s.code,{children:"TP7/app/src/main/kotlin/Analyzer.kt"}),". Suivez les taches suivantes."]}),"\n",(0,i.jsxs)(s.ol,{start:"0",children:["\n",(0,i.jsx)(s.li,{children:"Regardez la classe dans le fichier TP7.kt. Observez les choses suivantes:"}),"\n"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"la m\xe9thode g\xe9n\xe9rale analyse, qui re\xe7oit comme argument une instance quelconque qui impl\xe8mente l\u2019interface AstObject"}),"\n",(0,i.jsxs)(s.li,{children:["la m\xe9thode ",(0,i.jsx)(s.code,{children:"analyseBlock()"}),", o\xf9 on ignore les d\xe9finitions et les d\xe9clarations"]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"warning",children:(0,i.jsx)(s.p,{children:"N\u2019oubliez pas, pour les exercices 1-3, de traiter aussi les cas d\u2019erreur! Si on a des erreurs s\xe9mantiques, on n\u2019affiche plus l\u2019AST r\xe9sultant apr\xe8s l\u2019analyse, mais une liste qui contient que les erreurs."})}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:["Suivez les ",(0,i.jsx)(s.code,{children:"TODO-1"})," pour ajouter une variable et son type dans le tableau de symboles au moment de son d\xe9claration. Ignorez, pour cet exercice, les d\xe9clarations qui contiennent aussi une valeur d\u2019initialisation."]}),"\n",(0,i.jsx)(s.p,{children:"Pour les variables, v\xe9rifiez qu\u2019elles ne soient pas d\xe9j\xe0 d\xe9clar\xe9es."}),"\n",(0,i.jsxs)(s.p,{children:["Pour les types, soit on a des primitives, le cas o\xf9 vous pouvez ajouter une instance du type corr\xe9spondant dans le tableau de symboles, soit on a des types d\xe9finis par l\u2019utilisateur. Dans cette situation, il faut v\xe9rifier si le type existe ou non. On consid\xe8re comme primitives les types ",(0,i.jsx)(s.code,{children:"integer"}),", ",(0,i.jsx)(s.code,{children:"float"}),", ",(0,i.jsx)(s.code,{children:"boolean"}),", ",(0,i.jsx)(s.code,{children:"string"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"info",children:(0,i.jsxs)(s.p,{children:["Pour tester votre programme, utilisez les entr\xe9es dans les dossiers ",(0,i.jsx)(s.code,{children:"Inputs/Exn"}),". Elles contiennent des ASTs sous la forme JSON. On vous a prepar\xe9 d\xe9j\xe0 le moyen pour les d\xe9serializer et pour commencer \xe0 les analyser. Vous devez changer seulement le chemin vers le fichier de test d\xe9sir\xe9."]})}),"\n",(0,i.jsxs)(s.ol,{start:"2",children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:["Suivez les ",(0,i.jsx)(s.code,{children:"TODO-2"})," pour v\xe9rifier dans une expr\xe9ssion math\xe9matique le type r\xe9sultant. Le type se retrouvera dans le membre ",(0,i.jsx)(s.code,{children:"typeName"})," de chaque instance. Pour faire cela, il faut v\xe9rifier les types des composantes de l\u2019expr\xe9ssion. Pour ce TP, les expressions peuvent \xeatre des expressions binaires, unaires, des valeurs et des identificateurs. Pour les valeurs, v\xe9rifiez le type de chacune. Pour les identificateurs, cherchez leur type dans les tableaux de symboles."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:["Suivez les ",(0,i.jsx)(s.code,{children:"TODO-3"})," pour v\xe9rifier, dans une affectation, que les types de donn\xe9es corr\xe9spondent. Cherchez dans les tableaux de symboles le type de la partie gauche et celui de la partie droite et ensuite comparez-les. Vous pouvez considerer les types float et int compatibles."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"bibliographie",children:"Bibliographie"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"Compilers: Principles, Techniques & Tools - 2nd Edition"})," - Chapitres 2.7, 6.5"]}),"\n"]})]})}function u(e={}){const{wrapper:s}={...(0,r.M)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},6596:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/07_chained_symbol_tables-cd3431c61405041f134399a976531a16.png"},7788:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/07_symbol_table_compiler-5ba95f30cc8d4aa8092e765da8adfa4f.png"},2172:(e,s,n)=>{n.d(s,{I:()=>l,M:()=>t});var i=n(1504);const r={},a=i.createContext(r);function t(e){const s=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(a.Provider,{value:s},e.children)}}}]);