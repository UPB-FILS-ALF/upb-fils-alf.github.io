"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7312],{1207:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var s=r(4848),a=r(8453);const i={sidebar_position:6,description:"Introduction en ANTLR",slug:"/tp/05"},t="05 - ANTLR Lexer et Analyseur",l={id:"tp/05/index",title:"05 - ANTLR Lexer et Analyseur",description:"Introduction en ANTLR",source:"@site/docs/tp/05/index.md",sourceDirName:"tp/05",slug:"/tp/05",permalink:"/docs/tp/05",draft:!1,unlisted:!1,editUrl:"https://github.com/UPB-FILS-alf/upb-fils-alf.github.io/edit/main/docs/tp/05/index.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,description:"Introduction en ANTLR",slug:"/tp/05"},sidebar:"tutorialSidebar",previous:{title:"04 - Grammaires ind\xe9pendantes de contexte",permalink:"/docs/tp/04"}},o={},d=[{value:"Lexer",id:"lexer",level:2},{value:"Analyseur (Parser)",id:"analyseur-parser",level:2},{value:"Grammaires avec ANTLR4",id:"grammaires-avec-antlr4",level:2},{value:"Terminaux",id:"terminaux",level:3},{value:"R\xe8gles",id:"r\xe8gles",level:3},{value:"Exemple",id:"exemple",level:2},{value:"Analyseur et Lexer avec ANTLR",id:"analyseur-et-lexer-avec-antlr",level:2},{value:"Lexer",id:"lexer-1",level:3},{value:"Parser",id:"parser",level:3},{value:"Visualisation de l\u2019arbre d\u2019analyse (parse tree)",id:"visualisation-de-larbre-danalyse-parse-tree",level:3},{value:"Exercices",id:"exercices",level:2},{value:"Bibliographie",id:"bibliographie",level:2}];function c(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",math:"math",mi:"mi",mrow:"mrow",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"05---antlr-lexer-et-analyseur",children:"05 - ANTLR Lexer et Analyseur"}),"\n",(0,s.jsx)(n.p,{children:"Le TP pr\xe9c\xe9dent, on a vu comment \xe9crire des grammaire pour d\xe9crire les langages de programmation. Maintenant, on commence la transition de la partie des langages formels vers les compilateurs."}),"\n",(0,s.jsx)(n.h2,{id:"lexer",children:"Lexer"}),"\n",(0,s.jsxs)(n.p,{children:["Le ",(0,s.jsx)(n.strong,{children:"Lexer"})," est une composante du compilateur. Son but est de lire le texte d\u2019entr\xe9e (qui est notre programme source) et de produire en tant que sortie une ",(0,s.jsx)(n.strong,{children:"s\xe9quence de j\xe9tons"}),". Les erreurs qui apparaissent au niveau du ",(0,s.jsx)(n.strong,{children:"Lexer"})," sont des ",(0,s.jsx)(n.strong,{children:"erreurs d\u2019analyze lexicale"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Dans le contexte du Lexer, on introduit les d\xe9finitions suivantes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["le ",(0,s.jsx)(n.strong,{children:"j\xe9ton"})," (",(0,s.jsx)(n.strong,{children:"token"}),") est une paire qui contient le nom du j\xe9ton et une valeur. Le nom du j\xe9ton est un symbole abstrait qui repr\xe9sente un genre d\u2019unit\xe9 lexicale."]}),"\n",(0,s.jsxs)(n.li,{children:["le ",(0,s.jsx)(n.strong,{children:"mod\xe8le"})," est une description de la forme que les lexemes d\u2019un j\xe9ton peuvent avoir. Si le j\xe9ton repr\xe9sent un mot cl\xe9 (par exemple, le mot cl\xe9 if), le j\xe9tons est une cha\xeene de caract\xe8res qui composent le mot. Pour d\u2019autres situations (par exemple, pour d\xe9finir des noms pour les variables), on utilise des expr\xe9ssions plus complexes (comme les RegEx)."]}),"\n",(0,s.jsxs)(n.li,{children:["le ",(0,s.jsx)(n.strong,{children:"lex\xe8me"})," est une s\xe9quence de caract\xe8res dans le programme source qui correspond au mod\xe8le d\u2019un j\xe9ton et est identifi\xe9 par le Lexer comme une instance du j\xe9ton."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Exemples_Tokens",src:r(3428).A+"",width:"1515",height:"500"})}),"\n",(0,s.jsx)(n.h2,{id:"analyseur-parser",children:"Analyseur (Parser)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"L'Analyseur"})," obtient la s\xe9quence de j\xe9tons produite par le Lexer et v\xe9rifie si elle peut \xeatre g\xe9n\xe9r\xe9e par la grammaire du langage source. La sortie du Analyseur est l\u2019arbre d\u2019analyze (Parse Tree). Les erreurs qui apparaissent au niveau du Analyseur sont des ",(0,s.jsx)(n.strong,{children:"erreurs d\u2019analyse syntaxique"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Lexer_And_Parser",src:r(1606).A+"",width:"1483",height:"515"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"Vous pouvez ignorer, pour ce TP, le tableu de symboles. On va le discuter dans un TP prochain!"})}),"\n",(0,s.jsx)(n.h2,{id:"grammaires-avec-antlr4",children:"Grammaires avec ANTLR4"}),"\n",(0,s.jsx)(n.p,{children:"\xc0 partir de ce TP, on va utiliser ANTLR pour l\u2019analyse du texte. ANTLR (ANother Tool For Language Recognition) est un outil pour generer des analyseurs (parsers) qui permettent le traitement, l\u2019ex\xe9cution et la traduction du code. On va employer ANTLR pour la partie de front-end de notre compilateur."}),"\n",(0,s.jsxs)(n.p,{children:["Pour les grammaires ind\xe9pendantes du contexte, ANTLR utilise des fichiers ",(0,s.jsx)(n.code,{children:".g4"}),". Pour \xe9crire une grammaire, il faut cr\xe9er un fichier avec le m\xeame nom que la grammaire que vous souhaitez d\xe9finir."]}),"\n",(0,s.jsx)(n.h3,{id:"terminaux",children:"Terminaux"}),"\n",(0,s.jsxs)(n.p,{children:["En ANTLR, on peut m\xeame utiliser des productions pour d\xe9crire les terminaux. Dans ce cas, le corps de la production doit contenir que des terminaux. On va identifier les terminaux avec des noms qui commencent avec des lettres ",(0,s.jsx)(n.strong,{children:"MAJUSCULES"})," (On vous conseile d\u2019utiliser que des majuscules pour les terminaux, pour pouvoir les distinguer plus facilement). D\u2019habitude, on trouve les d\xe9finitions des terminaux \xe0 la fin de la grammaire."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-antlr4",children:"  INTEGER: (-)?[0-9]+ ;  //un terminal pour repr\xe9senter les nombres enti\xe8res\n  WHITESPACE: ' ' ; //un terminal pour repr\xe9senter les espaces blancs\n  VARIABLE_NAME: [a-zA-Z]+ //un terminal pour repr\xe9senter les noms des variables\n"})}),"\n",(0,s.jsx)(n.h3,{id:"r\xe8gles",children:"R\xe8gles"}),"\n",(0,s.jsxs)(n.p,{children:["On va identifier les non-terminaux avec des lettres ",(0,s.jsx)(n.strong,{children:"minuscules"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["En ANTLR, on ",(0,s.jsx)(n.strong,{children:"ne peut pas avoir des productions avec la m\xeame t\xeate"}),". Ce qu\u2019on peut faire, c\u2019est de mettre les deux corps dans un seul et de les s\xe9parer avec l\u2019op\xe9rateur ",(0,s.jsx)(n.code,{children:"|"}),"."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-antlr4",children:"  assignment: VARIABLE_NAME '=' INTEGER ; //une r\xe8gle pour repr\xe9senter une affectation\n  \n  //une r\xe8gle pour repr\xe9senter une expression d'addition\n  addition: addition '+' INTEGER\n          | INTEGER\n          ;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"exemple",children:"Exemple"}),"\n",(0,s.jsx)(n.p,{children:"Prenons la grammaire de la semaine derni\xe8re et \xe9crivons-la en ANTLR:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-antlr4",children:"grammar demo;\n\nZERO: '0';\nONE: '1'; \np : s '+'s;\ns : ZERO s ONE  \n  | ZERO ONE\n  |;\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Nos conseils pour \xe9crire des grammaires pour les langages de programmation",type:"tip",children:[(0,s.jsx)(n.p,{children:"Quand vous commencez \xe0 \xe9crire une grammaire pour n\u2019importe quel langage de programmation, on vous conseil de suivre les \xe9tapes suivantes:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"identifiez les instructions possibles dans le langage (la d\xe9claration des variables, les boucles, les instructions de contr\xf4le)"}),"\n",(0,s.jsx)(n.li,{children:"pour chacune de cettes instructions, d\xe9terminez les parties composantes (les mot cl\xe9s, les noms des variables/fonctions, les expr\xe9ssions math\xe9matiques)"}),"\n",(0,s.jsx)(n.li,{children:"pour chacune de cettes instructions, \xe9crivez les r\xe8gles de Lexer pour ses composantes et, ensuite, \xe9crivez une r\xe8gle pour d\xe9crire l\u2019instruction elle-m\xeame"}),"\n",(0,s.jsx)(n.li,{children:"v\xe9rifiez, apr\xe8s chaque nouvelle instruction ajout\xe9e, le comportement du Lexer et Parser g\xe9n\xe9r\xe9s par ANTLR."}),"\n"]})]}),"\n",(0,s.jsx)(n.h2,{id:"analyseur-et-lexer-avec-antlr",children:"Analyseur et Lexer avec ANTLR"}),"\n",(0,s.jsx)(n.p,{children:"Au lieu d\u2019\xe9crire vous-m\xeames le lexer et l'analyseur, ANTLR peut les g\xe9n\xe9rer automatiquement \xe0 partir de votre grammaire. Vous devez seulement les utiliser dans votre code."}),"\n",(0,s.jsxs)(n.p,{children:["Le fichier avec la grammaire doit se trouver sous le chemin ",(0,s.jsx)(n.code,{children:"src/main/antlr"}),". Apr\xe8s la g\xe9n\xe9ration, vous trouvez aussi le dossier ",(0,s.jsx)(n.code,{children:".antlr"}),", qui contient tous les fichiers g\xe9n\xe9r\xe9s par antlr.\n",(0,s.jsx)(n.img,{alt:"antlr_file_hierarchy",src:r(9947).A+"",width:"597",height:"671"})]}),"\n",(0,s.jsx)(n.p,{children:"Pour utiliser ces nouveaux fichiers dans votre code, il faut seulement instantier les classes."}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["Les noms du lexer et analyseur auront le format suivant: ",(0,s.jsx)(n.code,{children:"<nom_de_votre_grammaire>Lexer"})," et ",(0,s.jsx)(n.code,{children:"<nom_de_votre_grammaire>Parser"}),". Ils sont des sous-classes des classes Lexer et Parser. Pour voir plusieurs d\xe9tails sur ces classes et les m\xe9thodes qu\u2019elles exposent, on vous conseille d\u2019ouvrir la documentation: ",(0,s.jsx)(n.a,{href:"https://www.antlr.org/api/Java/org/antlr/v4/runtime/Lexer.html",children:"lexer"})," et ",(0,s.jsx)(n.a,{href:"https://www.antlr.org/api/Java/org/antlr/v4/runtime/Parser.html",children:"parser"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"lexer-1",children:"Lexer"}),"\n",(0,s.jsx)(n.p,{children:"L\u2019exemple suivant montre comment utiliser le Lexer g\xe9n\xe9r\xe9 par ANTLR \xe0 partir de notre grammaire:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'  //Afficher les valeurs des j\xe9tons du texte\n  import org.antlr.v4.runtime.CharStreams\n  import org.antlr.v4.runtime.CommonTokenStream\n\n  fun main(){\n      val strToParse = "0011+01"\n      val lexer = demoLexer(CharStreams.fromString(strToParse))\n      val listOfTokens = lexer.allTokens\n      for(token in listOfTokens){\n          println("Token with value ${token.text} found at line ${token.line} starting from index ${token.startIndex}")\n      }\n  }\n'})}),"\n",(0,s.jsx)(n.p,{children:"La sortie sera:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"  Token with value 0 found at line 1 starting from index 0\n  Token with value 0 found at line 1 starting from index 1\n  Token with value 1 found at line 1 starting from index 2\n  Token with value 1 found at line 1 starting from index 3\n  Token with value + found at line 1 starting from index 4\n  Token with value 0 found at line 1 starting from index 5\n  Token with value 1 found at line 1 starting from index 6\n"})}),"\n",(0,s.jsx)(n.h3,{id:"parser",children:"Parser"}),"\n",(0,s.jsxs)(n.p,{children:["Les m\xe9thodes du notre parser sont obtenues \xe0 partir de la grammaire. Dans cet exemple, on commence la construction de l'arbre d\u2019analyse avec la production qui a comme t\xeate la variable ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"p"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"p"})]})})]}),". D\u2019habitude, on commence l\u2019analyse avec la r\xe9gle de d\xe9but de notre grammaire."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'  //Afficher les valeurs des j\xe9tons du texte\n  import org.antlr.v4.runtime.CharStreams\n  import org.antlr.v4.runtime.CommonTokenStream\n\n  fun main(){\n      val strToParse = "0011+01"\n      val lexer = demoLexer(CharStreams.fromString(strToParse))\n      val parser = demoParser(CommonTokenStream(lexer))\n      val tree = parser.p()\n      println(tree.text)\n      for(i in 0 until tree.childCount){\n          println(tree.getChild(i).text)\n      }\n  }\n'})}),"\n",(0,s.jsx)(n.p,{children:"La sortie sera:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"  0011+01\n  0011\n  +\n  01\n"})}),"\n",(0,s.jsxs)(n.p,{children:["On peut voir ici les sorties suivantes: la premi\xe8re ligne est le texte entier (qui corr\xe9spond au texte de la variable ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"p"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"p"})]})})]}),", la racine de notre arbre d\u2019analyse). Ensuite, on prend les noeuds enfants, qui doivent \xeatre une occurence de ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"s"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"s"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"s"})]})})]}),", un caract\xe8re ",(0,s.jsx)(n.code,{children:"+"})," et une autre occurence de ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"s"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"s"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"s"})]})})]}),". On peut voir que la sortie correspond aux demandes."]}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsx)(n.p,{children:"On vous conseil de ne pas combiner les deux exemples. C\u2019est-\xe0-dire, soit vous utilisez le Lexer pour afficher/travailler avec les j\xe9tons, soit vous continuez avec le Parser."}),(0,s.jsx)(n.p,{children:"On dit cela parce que les m\xe8thodes du Lexer comme getAllTokens ou nextToken() consomme les j\xe9tons. Si vous utilisez les premiers trois j\xe9tons et ensuite vous continuez avec le Parser, il commencera \xe0 partir du quatri\xe8me j\xe9ton."})]}),"\n",(0,s.jsx)(n.h3,{id:"visualisation-de-larbre-danalyse-parse-tree",children:"Visualisation de l\u2019arbre d\u2019analyse (parse tree)"}),"\n",(0,s.jsxs)(n.p,{children:["\xc0 partir de notre code source et de la grammaire, ANTLR peut aussi g\xe9n\xe9rer une repr\xe9sentation graphique de notre ",(0,s.jsx)(n.strong,{children:"arbre d\u2019analyse"})," (",(0,s.jsx)(n.strong,{children:"parse tree"}),"). Pour faire cela, on a besoin du code suivant:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'  import org.antlr.v4.runtime.CharStreams\n  import org.antlr.v4.runtime.CommonTokenStream\n  import org.antlr.v4.gui.TreeViewer\n  import java.io.File\n\n  fun main(){\n      val strToParse = "0011+01"\n      val lexer = demoLexer(CharStreams.fromString(strToParse))\n      val parser = demoParser(CommonTokenStream(lexer))\n      val tree = parser.p()\n      val viewer : TreeViewer = TreeViewer(parser.ruleNames.toMutableList(), tree)\n      viewer.open()\n  }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Quand on ex\xe9cute le programme, on obtient la fen\xeatre suivante:\n",(0,s.jsx)(n.img,{alt:"parse_tree_graph",src:r(1247).A+"",width:"977",height:"964"})]}),"\n",(0,s.jsx)(n.h2,{id:"exercices",children:"Exercices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["(R\xe9vision du TP pr\xe9c\xe9dent) Ouvrez le dossier ",(0,s.jsx)(n.code,{children:"TP5"}),". Suivez les ",(0,s.jsx)(n.code,{children:"TODO-1A"})," dans le fichier ",(0,s.jsx)(n.code,{children:"app/src/main/antlr/tp5.g4"})," pour \xe9crire une grammaire qui accepte des d\xe9clarations des variables ayant la syntaxe suivante:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"  <type> <nom_variable>;\n\n  //Exemples\n  int var1;\n  float _a1b2;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Les types possibles sont ",(0,s.jsx)(n.code,{children:"int"})," et ",(0,s.jsx)(n.code,{children:"float"}),". Les noms des variables sont des cha\xeenes de caract\xe8res qui peuvent commencer avec un ",(0,s.jsx)(n.code,{children:"_"})," et peuvent contenir des lettres et des chiffres."]}),"\n",(0,s.jsxs)(n.p,{children:["Suivez les ",(0,s.jsx)(n.code,{children:"TODO-1B"})," dans le m\xeame fichier pour que la grammaire accepte aussi des expressions math\xe9matiques avec des nombres et des variables, en utilisant les op\xe9rateurs ",(0,s.jsx)(n.code,{children:"+"}),", ",(0,s.jsx)(n.code,{children:"-"}),", ",(0,s.jsx)(n.code,{children:"*"}),", ",(0,s.jsx)(n.code,{children:"/"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"  //Exemple\n  2*3+a;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Finalement, suivez les ",(0,s.jsx)(n.code,{children:"TODO-1C"})," dans le m\xeame fichier pour que la grammaire accepte aussi des affectations (assignments):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"  <nom_variable> = <expression>;\n\n  //Exemple\n  _ab2 = 12*7+var1;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Testez par compiler et ex\xe9cuter le code. Voyez l\u2019arbre d\u2019analyse et v\xe9rifiez vos r\xe9sultats avec des exemples."}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["Suivez les ",(0,s.jsx)(n.code,{children:"TODO-2"})," pour \xe9crire une grammaire qui accepte des instructions ",(0,s.jsx)(n.code,{children:"if"})," ayant la syntaxe suivante:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"  if(<expression>){\n    <z\xe9ro ou plusieurs instructions>\n  }\n\n  //Exemples\n  if(2+3/_variable){\n    _var2 = 20;\n    5*3;\n  }\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["Suivez les ",(0,s.jsx)(n.code,{children:"TODO-3"})," pour \xe9crire une grammaire qui accepte des d\xe9finitions des fonctions sans l'instruction de retour. Elles aurient la syntaxe suivante:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"  <type_de_retour> <nom_de_la_fonction>(type1 param1, type2 param2 ...){\n    <z\xe9ro ou plusieurs instructions>\n  }\n\n  //Exemples\n  int func(int a, float b){\n    a = 2 * b;\n    int _innervar;\n    _innervar = a+b;\n  }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"bibliographie",children:"Bibliographie"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Compilers: Principles, Techniques & Tools - 2nd Edition"})," - Chapitres 3.1, 4.1"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.antlr.org/api/Java/org/antlr/v4/runtime/Lexer.html",children:"ANTLR Lexer"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.antlr.org/api/Java/org/antlr/v4/runtime/Parser.html",children:"ANTLR Parser"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/antlr/grammars-v4",children:"R\xe8gles en ANTLR pour des langages de programmation"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1247:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/05_parse_tree_graph-3a185deccc6db9d9810fe5d315dc623b.png"},1606:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/05_lexer_parser-4fdfe450aa11fd4f2660fb8f27595ef1.png"},3428:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/05_tokens_examples-1a73d5e44183a3ae386254b120b0a0b5.png"},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var s=r(6540);const a={},i=s.createContext(a);function t(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),s.createElement(i.Provider,{value:n},e.children)}},9947:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/05_antlr_generated_files-94bebb2e8291e342f8d406625fb31e61.png"}}]);